#!/usr/bin/env python3
"""
Complete CGen Pipeline with Integrated Generator

This demonstrates the complete pipeline using the integrated CGen generator:
1. Python code analysis with intelligence layer
2. C code generation using integrated CGenFactory with function bodies
3. Compilation and execution validation

The integrated generator supports function bodies, unlike the basic cfile library.
"""

import ast
import sys
import os
import subprocess
import tempfile
from pathlib import Path

# Add project root to path
project_root = Path(__file__).parent.parent
sys.path.append(str(project_root))
sys.path.append(str(project_root / "src"))

from src.cgen.intelligence.analyzers import StaticAnalyzer, BoundsChecker, CallGraphAnalyzer
from src.cgen.intelligence.optimizers import CompileTimeEvaluator, VectorizationDetector
from src.cgen.intelligence.base import AnalysisContext, AnalysisLevel, OptimizationLevel
from src.cgen.frontend.ast_analyzer import ASTAnalyzer
from src.cgen.generator import CGenFactory, CGenWriter, StyleOptions


# Example Python code demonstrating optimization opportunities
PYTHON_CODE = '''
def factorial(n: int) -> int:
    """Recursive function for call graph analysis."""
    if n <= 1:
        return 1
    return n * factorial(n - 1)

def vector_add(a: list, b: list) -> list:
    """Vectorizable operation."""
    result = []
    for i in range(len(a)):
        result.append(a[i] + b[i])
    return result

def compute_area(radius: float) -> float:
    """Function with compile-time constants."""
    pi = 3.141592653589793
    return pi * radius * radius
'''


def analyze_python_code():
    """Run comprehensive intelligence layer analysis."""
    print("ðŸ§  Intelligence Layer Analysis")
    print("=" * 40)

    # Create analysis context
    ast_node = ast.parse(PYTHON_CODE)
    analyzer = ASTAnalyzer()
    analysis_result = analyzer.analyze(PYTHON_CODE)
    context = AnalysisContext(PYTHON_CODE, ast_node, analysis_result,
                             AnalysisLevel.COMPREHENSIVE, OptimizationLevel.AGGRESSIVE)

    results = {}

    # Static Analysis
    print(" Static Analyzer...")
    static_analyzer = StaticAnalyzer()
    static_result = static_analyzer.analyze(context)
    results['static'] = static_result
    print(f"  Success: {static_result.success}, Confidence: {static_result.confidence:.2f}")

    # Bounds Checking
    print("  Bounds Checker...")
    bounds_checker = BoundsChecker()
    bounds_result = bounds_checker.analyze(context)
    results['bounds'] = bounds_result
    print(f"  Success: {bounds_result.success}, Confidence: {bounds_result.confidence:.2f}")

    # Call Graph Analysis
    print(" Call Graph Analyzer...")
    call_graph = CallGraphAnalyzer()
    graph_result = call_graph.analyze(context)
    results['call_graph'] = graph_result
    print(f"  Success: {graph_result.success}, Confidence: {graph_result.confidence:.2f}")

    # Compile-Time Evaluation
    print(" Compile-Time Evaluator...")
    evaluator = CompileTimeEvaluator()
    eval_result = evaluator.optimize(context)
    results['compile_time'] = eval_result
    print(f"  Success: {eval_result.success}, Speedup: {eval_result.performance_gain_estimate:.2f}x")

    # Vectorization Detection
    print(" Vectorization Detector...")
    detector = VectorizationDetector()
    vector_result = detector.analyze(context.ast_node)
    results['vectorization'] = vector_result
    print(f"  Loops analyzed: {vector_result.total_loops_analyzed}, Vectorizable: {vector_result.vectorizable_loops}")

    return results


def generate_c_code_with_integrated_generator(analysis_results):
    """Generate C code using the integrated CGen generator with function body support."""
    print("\n Generating C Code with Integrated Generator")
    print("=" * 50)

    # Create factory and writer
    C = CGenFactory()
    writer = CGenWriter(StyleOptions())

    # Create main code sequence
    code = C.sequence()

    # Add intelligence header as comments
    print(" Adding intelligence analysis header...")
    code.append(C.line_comment("=" * 60))
    code.append(C.line_comment("Generated by CGen Intelligence Layer"))

    # Count successful analyses
    successful_analyzers = sum(1 for result in analysis_results.values()
                             if hasattr(result, 'success') and result.success)
    code.append(C.line_comment(f"Analysis Results: {successful_analyzers} successful components"))

    # Add performance estimates
    eval_result = analysis_results.get('compile_time')
    if eval_result and eval_result.success:
        speedup = eval_result.performance_gain_estimate
        code.append(C.line_comment(f"Compile-time optimization: {speedup:.2f}x speedup"))

    code.append(C.line_comment("=" * 60))
    code.append(C.blank())

    # Add includes
    print(" Adding includes...")
    code.append(C.sysinclude("stdio.h"))
    code.append(C.sysinclude("math.h"))
    code.append(C.blank())

    # Add compile-time optimized constants
    eval_result = analysis_results.get('compile_time')
    if eval_result and eval_result.success:
        print(" Adding compile-time optimized constants...")
        pi_constant = C.compile_time_constant("PI", "3.141592653589793", eval_result)
        code.append(C.line_comment("Compile-time optimized constant"))
        code.append(pi_constant)
        code.append(C.blank())

    # Generate factorial function (identified by call graph analysis)
    print(" Generating factorial function with body...")
    factorial_func = C.function("factorial", "int")
    factorial_func.make_param("n", "int")

    # Add function body using enhanced API
    factorial_func.add_statement("if (n <= 1) return 1")
    factorial_func.add_statement("return n * factorial(n - 1)")

    code.append(C.declaration(factorial_func))
    code.append(C.blank())

    # Generate optimized area function
    print(" Generating optimized area function...")
    area_func = C.function("compute_area", "double")
    area_func.make_param("radius", "double")
    area_func.add_statement("return PI * radius * radius")

    code.append(C.declaration(area_func))
    code.append(C.blank())

    # Generate vectorizable array addition function
    vector_result = analysis_results.get('vectorization')
    if vector_result and vector_result.vectorizable_loops > 0:
        print(" Generating vectorizable array function...")
        code.append(C.line_comment("Vectorizable operation - SIMD optimization opportunity"))

    add_func = C.function("vector_add", "void")
    add_func.make_param("a", "double*")
    add_func.make_param("b", "double*")
    add_func.make_param("result", "double*")
    add_func.make_param("size", "int")

    # Add vectorizable loop body
    add_func.add_statement("int i")
    add_func.add_statement("for (i = 0; i < size; i++)")
    add_func.add_statement("    result[i] = a[i] + b[i]")

    code.append(C.declaration(add_func))
    code.append(C.blank())

    # Generate memory-safe array sum
    bounds_result = analysis_results.get('bounds')
    if bounds_result and bounds_result.confidence > 0.8:
        print("  Generating memory-safe array sum...")
        code.append(C.line_comment("Memory safety verified by static analysis"))

    sum_func = C.function("safe_array_sum", "double")
    sum_func.make_param("data", "double*")
    sum_func.make_param("size", "int")

    sum_func.add_statement("double total = 0.0")
    sum_func.add_statement("int i")
    sum_func.add_statement("for (i = 0; i < size; i++)")
    sum_func.add_statement("    total += data[i]")
    sum_func.add_statement("return total")

    code.append(C.declaration(sum_func))
    code.append(C.blank())

    # Generate main function with comprehensive tests
    print(" Generating comprehensive main function...")
    main_func = C.function("main", "int")

    # Test all generated functions
    main_func.add_statement("// Test recursive function")
    main_func.add_statement("int fact_result = factorial(5)")
    main_func.add_statement("")
    main_func.add_statement("// Test optimized area calculation")
    main_func.add_statement("double area_result = compute_area(2.0)")
    main_func.add_statement("")
    main_func.add_statement("// Test vectorizable array operations")
    main_func.add_statement("double a[4] = {1.0, 2.0, 3.0, 4.0}")
    main_func.add_statement("double b[4] = {5.0, 6.0, 7.0, 8.0}")
    main_func.add_statement("double result[4]")
    main_func.add_statement("vector_add(a, b, result, 4)")
    main_func.add_statement("")
    main_func.add_statement("// Test memory-safe array sum")
    main_func.add_statement("double sum_result = safe_array_sum(a, 4)")
    main_func.add_statement("")

    # Display results with intelligence annotations
    main_func.add_statement('printf("=== CGen Intelligence-Optimized Results ===\\n")')
    main_func.add_statement('printf("Factorial(5) = %d\\n", fact_result)')
    main_func.add_statement('printf("Area(r=2.0) = %.6f (using compile-time PI)\\n", area_result)')
    main_func.add_statement('printf("Vector addition: [%.1f, %.1f, %.1f, %.1f]\\n", result[0], result[1], result[2], result[3])')
    main_func.add_statement('printf("Safe array sum: %.1f\\n", sum_result)')
    main_func.add_statement('printf("\\n--- Intelligence Layer Optimizations ---\\n")')

    # Add performance information
    speedup = eval_result.performance_gain_estimate if eval_result and eval_result.success else 1.0
    main_func.add_statement(f'printf("â€¢ Compile-time optimization: {speedup:.2f}x speedup\\n")')

    if vector_result and vector_result.vectorizable_loops > 0:
        main_func.add_statement('printf("â€¢ Vectorization opportunities identified\\n")')

    if bounds_result and bounds_result.confidence > 0.8:
        main_func.add_statement('printf("â€¢ Memory safety verification completed\\n")')

    main_func.add_statement("")
    main_func.add_statement("return 0")

    code.append(C.declaration(main_func))

    # Generate the C code
    print(" Converting to C code string...")
    c_code = writer.write_str(code)

    return c_code


def compile_and_run(c_code: str):
    """Compile and run the generated C code."""
    print(f"\n Compiling and Running")
    print("=" * 40)

    try:
        # Write C code to temporary file
        with tempfile.NamedTemporaryFile(mode='w', suffix='.c', delete=False) as f:
            f.write(c_code)
            c_file = f.name

        # Compile
        executable = c_file.replace('.c', '')
        cmd = ['gcc', '-o', executable, c_file, '-lm']

        print(f" Compiling: {' '.join(cmd)}")
        result = subprocess.run(cmd, capture_output=True, text=True)

        if result.returncode == 0:
            print(" Compilation successful!")

            # Run
            print(" Running executable...")
            run_result = subprocess.run([executable], capture_output=True, text=True)

            if run_result.returncode == 0:
                print(" Execution successful!")
                print(" Output:")
                for line in run_result.stdout.strip().split('\n'):
                    print(f"  {line}")
                return True
            else:
                print(f" Execution failed: {run_result.stderr}")
                return False
        else:
            print(f" Compilation failed: {result.stderr}")
            return False

    except Exception as e:
        print(f" Exception: {e}")
        return False

    finally:
        # Cleanup
        try:
            if 'c_file' in locals():
                os.unlink(c_file)
            if 'executable' in locals() and os.path.exists(executable):
                os.unlink(executable)
        except:
            pass


def main():
    """Main demonstration."""
    print(" Complete CGen Pipeline with Integrated Generator")
    print("=" * 60)
    print("Python Analysis â†’ C Generation (with function bodies) â†’ Compilation â†’ Execution")
    print("=" * 60)

    # Step 1: Intelligence Layer Analysis
    analysis_results = analyze_python_code()

    # Step 2: Generate C Code with Integrated Generator
    c_code = generate_c_code_with_integrated_generator(analysis_results)

    print(f"\n Generated C Code with Function Bodies")
    print("=" * 50)
    print(c_code)

    # Step 3: Compile and Run
    success = compile_and_run(c_code)

    # Step 4: Summary
    print(f"\n Complete Pipeline Results")
    print("=" * 50)

    # Count successful components
    analyzers_success = sum(1 for key in ['static', 'bounds', 'call_graph']
                           if analysis_results.get(key) and analysis_results[key].success)

    # Calculate estimated performance improvement
    eval_result = analysis_results.get('compile_time')
    speedup = eval_result.performance_gain_estimate if eval_result and eval_result.success else 1.0

    vector_result = analysis_results.get('vectorization')
    if vector_result and vector_result.candidates:
        vector_speedup = sum(c.estimated_speedup for c in vector_result.candidates) / len(vector_result.candidates)
        speedup *= vector_speedup

    print(f" Intelligence Analysis: {analyzers_success}/3 analyzers successful")
    print(f" Estimated Performance Improvement: {speedup:.2f}x")
    print(f" C Code Generation:  Success (with function bodies!)")
    print(f" Compilation & Execution: {' Success' if success else ' Failed'}")

    print(f"\n Key Achievements:")
    print(f"    Integrated cfile as cgen.generator subpackage")
    print(f"    Extended Function class to support function bodies")
    print(f"    Intelligence-aware code generation methods")
    print(f"    Complete pipeline from Python analysis to C execution")
    print(f"    Demonstrated {speedup:.2f}x potential performance improvement")

    if success:
        print(f"\n Complete pipeline successful!")
        print(f"Python â†’ Intelligence Analysis â†’ C Generation (with bodies) â†’ Compilation â†’ Execution ")
    else:
        print(f"\n  Pipeline had compilation/execution issues")

    return success


if __name__ == "__main__":
    success = main()
    exit(0 if success else 1)