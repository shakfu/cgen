/* Generated by CGen Intelligence Layer with STC Support */
/* Optimizations applied: STC containers for performance */

// Unsupported type: list
#define T GridVec, int
#define T RowVec, int
#define T NeighborsVec, int
#define T BlinkerVec, int
#define T GliderVec, int

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <stc/vec.h>

// Unsupported type: list

int create_grid_stc(int width, int height) {
    GridVec grid = {0};
    int i = 0;
    while (i < height) {
        RowVec row = {0};
        int j = 0;
        while (j < width) {
            RowVec_push(&row, 0);
            j = j + 1;
        }
        GridVec_push(&grid, row);
        i = i + 1;
    }
    return grid;
}

void set_cell_stc(int grid, int x, int y, int state) {
    if (((0 <= y) && (y < GridVec_size(&grid)) && (0 <= x) && (x < (sizeof(grid[y])/sizeof(grid[y][0]))))) {
    }
}

int get_cell_stc(int grid, int x, int y) {
    if (((0 <= y) && (y < GridVec_size(&grid)) && (0 <= x) && (x < (sizeof(grid[y])/sizeof(grid[y][0]))))) {
        return grid[y][x];
    }
    return 0;
}

int count_neighbors_stc(int grid, int x, int y) {
    int count = 0;
    NeighborsVec neighbors = {0};
    NeighborsVec_push(&neighbors, {(-1), (-1)});
    NeighborsVec_push(&neighbors, {(-1), 0});
    NeighborsVec_push(&neighbors, {(-1), 1});
    NeighborsVec_push(&neighbors, {0, (-1)});
    NeighborsVec_push(&neighbors, {0, 1});
    NeighborsVec_push(&neighbors, {1, (-1)});
    NeighborsVec_push(&neighbors, {1, 0});
    NeighborsVec_push(&neighbors, {1, 1});
    for (c_each(it, NeighborsVec, neighbors)) {
        int neighbor = *it.ref;
        int nx = (x + neighbor[0]);
        int ny = (y + neighbor[1]);
        if (get_cell_stc(grid, nx, ny) == 1) {
            count += 1;
        }
    }
    return count;
}

int evolve_stc(int grid) {
    height = GridVec_size(&grid);
    if (height == 0) {
        return 0;
    }
    width = (sizeof(grid[0])/sizeof(grid[0][0]));
    int new_grid = create_grid_stc(width, height);
    int changes = 0;
    y = 0;
    while (y < height) {
        x = 0;
        while (x < width) {
            int current = get_cell_stc(grid, x, y);
            neighbors = count_neighbors_stc(grid, x, y);
            if (current == 1) {
                if ((neighbors == 2 || neighbors == 3)) {
                    set_cell_stc(new_grid, x, y, 1);
                } else {
                    set_cell_stc(new_grid, x, y, 0);
                    changes = 1;
                }
            } else {
                if (neighbors == 3) {
                    set_cell_stc(new_grid, x, y, 1);
                    changes = 1;
                } else {
                    set_cell_stc(new_grid, x, y, 0);
                }
            }
            x = x + 1;
        }
        y = y + 1;
    }
    y = 0;
    while (y < height) {
        x = 0;
        while (x < width) {
            x = x + 1;
        }
        y = y + 1;
    }
    return changes;
}

int count_live_cells_stc(int grid) {
    count = 0;
    for (c_each(it, GridVec, grid)) {
        int row = *it.ref;
        for (c_each(it, RowVec, row)) {
            int cell = *it.ref;
            if (cell == 1) {
                count += 1;
            }
        }
    }
    return count;
}

void initialize_pattern_stc(int grid, int pattern, int offset_x, int offset_y) {
    /* Complex for loop not supported */
}

void run_simulation_stc(void) {
    width = 20;
    height = 15;
    grid = create_grid_stc(width, height);
    BlinkerVec blinker = {0};
    BlinkerVec_push(&blinker, {0, 1});
    BlinkerVec_push(&blinker, {1, 1});
    BlinkerVec_push(&blinker, {2, 1});
    initialize_pattern_stc(grid, blinker, 5, 5);
    GliderVec glider = {0};
    GliderVec_push(&glider, {1, 0});
    GliderVec_push(&glider, {2, 1});
    GliderVec_push(&glider, {0, 2});
    GliderVec_push(&glider, {1, 2});
    GliderVec_push(&glider, {2, 2});
    initialize_pattern_stc(grid, glider, 10, 8);
    int generation = 0;
    while (generation < 10) {
        int live_cells = count_live_cells_stc(grid);
        printf("%s\n", "Generation VAR: VAR live cells");
        changes = evolve_stc(grid);
        if ((!changes)) {
            printf("%s\n", "Simulation stabilized - no more changes");
            /* Unsupported statement: Break */
        }
        generation = generation + 1;
    }
    printf("%s\n", "Simulation complete");
}

int main(void) {
    printf("%s\n", "Starting Conway's Game of Life with STC containers...");
    run_simulation_stc();
    printf("%s\n", "Game of Life simulation completed!");
    return 0;
}
